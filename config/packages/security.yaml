security:
    # Eventuellement, si l'on souhaite utiliser un cryptage particulier
    #encoders:
        #App\Entity\Member:
            #algorithm: bcrypt
            # Algorithm by default is auto
    # https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers
    providers:
        # used to reload user from session & other features (e.g. switch_user)
        app_member_provider:
            # id: App\Security\MemberProvider
            entity:
                class: App\Entity\Member
        app_staff_provider:
            entity:
                class: App\Entity\Staff
    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
        main:
            anonymous: true
            lazy: true
            provider: app_member_provider
            guard:
                authenticators:
                    - App\Security\MemberAuthenticator
                    - App\Security\StaffAuthenticator
                entry_point: App\Security\MemberAuthenticator
            logout:
                # En déclarant la propriété "path", on indique le "route name" de la fonction et du controller qui va être intercepté par Symfony
                # De ce fait, en vérité, dans la fonction "LoginController::logout", il n'y a pas besoin de rajouter du code. Symfony se charge de nettoyer la session utilisateur pour telle url
                path: logout
                # Après logout, on redirige vers la page principale de login (géré par Symfony, avant même l'exécution du controller)
                target: login_index

            # activate different ways to authenticate
            # https://symfony.com/doc/current/security.html#firewalls-authentication

            # https://symfony.com/doc/current/security/impersonating_user.html
            # switch_user: true

            # Ajout d'un "access denied" customisé
            access_denied_handler: App\Security\CustomAccessDeniedHandler


    # Il est important de définir la hiérarchie des rôles afin d'y intégrer les rôles spécifiques définis en base de données.
    ## Pour ce qui serait par exemple de donner des droits spécifiques aux users sur l'action de boutons dans une même page (par exemple, on ne fait apparaître le bouton "Supprimer" que pour les superadmin)
    ## ça se gèrera dans les templates twig
    role_hierarchy:
        ROLE_ADMIN: ROLE_USER
        # Pour le moment, tous les roles staffs sont équivalents
        superadmin: ROLE_ADMIN
        webmaster: ROLE_ADMIN
        bilbiothécaire: ROLE_ADMIN

    # Easy way to control access for large sections of your site
    # Note: Only the *first* access control that matches will be used
    access_control:
        - { path: ^/admin, roles: [ROLE_ADMIN, superadmin, webmaster, bibliothécaire] }
        - { path: ^/list, roles: ROLE_USER }
        - { path: ^/show, roles: ROLE_USER }
